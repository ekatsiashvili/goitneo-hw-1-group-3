# Завдання 1

На першому етапі вам потрібно реалізувати функцію для виведення списку колег, яких потрібно привітати з днем народження на тижні.

У вас є список словників users, кожен словник у ньому обов'язково має ключі name та birthday. Така структура представляє модель списку користувачів з їх іменами та днями народження. Де name — це рядок з ім'ям користувача, а birthday — це datetime об'єкт, в якому записаний день народження.

Наприклад:

{"name": "Bill Gates", "birthday": datetime(1955, 10, 28)}

Ваше завдання написати функцію get_birthdays_per_week, яка отримує на вхід список users і виводить у консоль (за допомогою print) список користувачів, яких потрібно привітати по днях на наступному тижні.
Рекомендації для виконання

Давайте розберемо покроковий план алгоритму для пошуку днів народження протягом наступного тижня

    Підготовка Даних: Перш ніж почати обчислення, потрібно зібрати відомості про користувачів. Ми очікуємо, в аргументі функції get_birthdays_per_week список словників users, де кожен словник містить ім'я та дату народження користувача. Як варіант, ми можемо зберігати дні народження необхідних користувачів в наступній структурі даних

{'Monday': ['Bill Gates'], 'Thursday': ['Jan Koum']}

Для цього ми можемо наприклад використати `defaultdict(list)`

    Отримання Поточної Дати: Отримуємо поточну дату системи для подальшого порівняння з датами народження користувачів datetime.today().date().
    Перебір Користувачів: Проходимо по списку користувачів та аналізуємо їх дати народження `for user in users:`.
    В середині циклу for проводимо аналіз дати народження: a. Конвертація Дати: Конвертуємо час народження до типу date, видаляючи часову частину. 

name = user["name"]
birthday = user["birthday"].date()  *# Конвертуємо до типу date*
birthday_this_year = birthday.replace(year=today.year)

b. Оцінка Дати на Цей Рік : Перевіряємо, чи вже минув день народження цього року if birthday_this_year < today. Якщо так, то розглядаємо дату на наступний рік, це треба у birthday_this_year використовуючи метод replace збільшити рік на одиничку. c. Порівняння з Поточною Датою: Визначаємо різницю між днем народження та поточним днем, щоб знайти дні народження на тиждень вперед delta_days = (birthday_this_year - today).days.

d. Визначення Дня Тижня: Визначаємо день тижня дня народження. Якщо це вихідний, переносимо на понеділок. Тут треба подивитись, щоб delta_days < 7, перед тим як визначити на який день ставимо поздоровлення.

    Зберігання Результату : Зберігаємо ім'я користувача в відповідний день тижня, якщо день народження відбувається протягом наступного тижня.
    Виведення Результату: Виводимо зібрані імена по днях тижня у відповідному форматі.

Критерії оцінювання

    Функція get_birthdays_per_week виводить імена іменинників у форматі:

Monday: Bill Gates, Jill Valentine
Friday: Kim Kardashian, Jan Koum

    Користувачів, у яких день народження був на вихідних, потрібно привітати в понеділок.
    Функція виводить користувачів з днями народження на тиждень вперед від поточного дня.
    Тиждень починається з понеділка.

Завдання 2

Напишіть консольного бота помічника, який розпізнаватиме команди, що вводяться з клавіатури, та буде відповідати відповідно до введеної команди.
Бот помічник повинен стати для нас прототипом застосунку-асистента який ми розробимо в наступних домашніх завданнях. Застосунок-асистент в першому наближенні повинен вміти працювати з книгою контактів та календарем.

У цій домашній роботі зосередимося на інтерфейсі самого бота.  Найпростіший і найзручніший на початковому етапі розробки інтерфейс - це консольний застосунок CLI (Command Line Interface). CLI достатньо просто реалізувати. Будь-який CLI складається з трьох основних елементів:

    Парсер команд. Частина, яка відповідає за розбір введених користувачем рядків, виділення з рядка ключових слів та модифікаторів команд.
    Функції обробники команд - набір функцій, які ще називають handler, вони відповідають за безпосереднє виконання команд.
    Цикл запит-відповідь. Ця частина застосунку відповідає за отримання від користувача даних та повернення користувачеві відповіді від функції - handler-а.

На першому етапі наш бот-асистент повинен вміти зберігати ім'я та номер телефону, знаходити номер телефону за ім'ям, змінювати записаний номер телефону, виводити в консоль всі записи, які зберіг. Щоб реалізувати таку нескладну логіку, скористаємося словником. У словнику будемо зберігати ім'я користувача як ключ і номер телефону як значення.
Рекомендації для виконання

По перше, нам треба систематизувати опис форматів наших команд для консольного бота-помічника. Це допоможе зрозуміти які функції треба зробити для кожної команди. Зробімо це:

    Команда "hello", тут можна обійтись поки без функції та використати звичайний print:
        Введення: "hello"
        Вивід: "How can I help you?"
    Команда "add [ім'я] [номер телефону]". Для цієї команди зробимо функцію add_contact:
        Введення: "add John 1234567890"
        Вивід: "Contact added."
    Команда "change [ім'я] [новий номер телефону]". Для цієї команди зробимо функцію change_contact:
        Введення: "change John 0987654321"
        Вивід: "Contact updated." або повідомлення про помилку, якщо ім'я не знайдено
    Команда "phone [ім'я]". Для цієї команди зробимо функцію show_phone:
        Введення: "phone John"
        Вивід: [номер телефону] або повідомлення про помилку, якщо ім'я не знайдено
    Команда "all". Для цієї команди зробимо функцію show_all:
        Введення: "all"
        Вивід: усі збережені контакти з номерами телефонів
    Команда "close" або "exit". Оскільки тут треба перервати виконання програми, можна поки обійтись без функції для цих команд:
        Введення: будь-яке з цих слів
        Вивід: "Good bye!" та завершення роботи бота

Будь-яка команда, яка не відповідає вищезазначеним форматам, буде вважатися нами невірною, і бот буде виводити повідомлення "Invalid command."

Почнемо з простого варіанту CLI-бота:

def main():
    print("Welcome to the assistant bot!")
    while True:
        command = input("Enter a command: ").strip().lower()

        if command in ["close", "exit"]:
            print("Good bye!")
            break

        elif command == "hello":
            print("How can I help you?")
        else:
            print("Invalid command.")

if __name__ == "__main__":
    main()

Коли програма запускається, вона виводить повідомлення "Welcome to the assistant bot!" і входить в нескінчений цикл, де вона очікує введення команди від користувача while True.

Якщо користувач вводить "good bye", "close" або "exit", програма виводить "Good bye!" та завершує роботу. За це відповідає блок коду:

if command in ["close", "exit"]:
            print("Good bye!")
            break

Якщо користувач вводить "hello", програма виводить "How can I help you?". Якщо ж введена команда не відповідає жодному з цих варіантів, програма виводить "Invalid command.".

Welcome to the assistant bot!
Enter a command: test
Invalid command.
Enter a command: hello
How can I help you?
Enter a command: exit
Good bye!

Цей код створює простий інтерактивний командний рядок, який реагує на обмежений набір команд. Ми реалізували цикл запит-відповідь який буде служити відмінною основою для додавання додаткової функціональності нашого домашнього завдання.

Тепер додамо парсер команд. Перепишемо наш код наступним чином

def parse_input(user_input):
    cmd, *args = user_input.split()
    cmd = cmd.strip().lower()
    return cmd, *args

def main():
    print("Welcome to the assistant bot!")
    while True:
        user_input = input("Enter a command: ")
        command, *args = parse_input(user_input)

        if command in ["close", "exit"]:
            print("Good bye!")
            break

        elif command == "hello":
            print("How can I help you?")
        else:
            print("Invalid command.")

if __name__ == "__main__":
    main()

Ми додали функцію parse_input(user_input) яка приймає рядок вводу користувача user_input і розбиває його на слова за допомогою методу split(). Вона повертає перше слово як команду cmd та решту як список аргументів *args. Рядок коду cmd, *args = user_input.split() розділяє рядок на слова. Перше слово зберігається у змінній cmd, а решта зберігається у списку args завдяки оператору розпакування *. Далі рядок коду cmd = cmd.strip().lower() видаляє зайві пробіли навколо команди та перетворює її на нижній регістр. ``
Навіщо приводити команду до нижнього регістру?

Припустимо, користувач вводить команду як "HELLO", "Hello" або "hello". Якщо не привести ці варіанти до спільного регістру, вони будуть розглядатися як різні команди, і вам доведеться обробляти кожний варіант окремо.

Приведення команди до нижнього регістру дозволяє уникнути цього, перетворюючи всі варіанти на одну та ту ж форму. Таким чином, ви можете легко порівнювати введену команду з попередньо визначеними командами без зважання на те, як користувач ввів її.

Це забезпечує кращий досвід користувача, оскільки програма стає менш чутливою до конкретного способу введення команд.

Отриманий результат в функції main ми отримаємо після виконання рядка коду command, *args = parse_input(user_input) .

Функція parse_input розбиває введений рядок на слова, використовуючи пробіл як розділювач. Змінна command отримує перше значення та вважається командою, а змінна args стає списком з усіх інших значень.

Наприклад якщо ми введемо команду "add John 123456" то змінна command стане рядком "add" а змінна args стане списком ["John", "123456"] . Якщо ж ми введемо команду "hello" то command стане рядком "hello", а args буде пустим списком []

Маю надію ви вже зрозуміли тепер принцип парсера, настав час додати команду add.

def parse_input(user_input):
    cmd, *args = user_input.split()
    cmd = cmd.strip().lower()
    return cmd, *args

def add_contact(args, contacts):
    name, phone = args
    contacts[name] = phone
    return "Contact added."

def main():
    contacts = {}
    print("Welcome to the assistant bot!")
    while True:
        user_input = input("Enter a command: ")
        command, *args = parse_input(user_input)

        if command in ["close", "exit"]:
            print("Good bye!")
            break
        elif command == "hello":
            print("How can I help you?")
        elif command == "add":
            print(add_contact(args, contacts))
        else:
            print("Invalid command.")

if __name__ == "__main__":
    main()

Ми додали словник з контактами contacts = {} в середину функції main та функцію обробник команди add_contact.

Функція add_contact призначена для додавання нового контакту до словника контактів. Вона приймає два аргументи: args, який є списком і містить ім'я та телефонний номер, та contacts, який є словником, де зберігаються контакти.

Всередині функції, два елементи зі списку args розпаковуються в змінні name та phone. Функція далі додає пару "ключ: значення" до словника контактів, використовуючи ім'я як ключ і телефонний номер як значення contacts[name] = phone.
Треба зауважити, що якщо контакт з таким ім'ям вже існує, його дані будуть перезаписані без будь-яких попереджень. Тут ви вже можете діяти на свій розсуд, хочете чи ні ви обробляти колізію, в нашому варіанті ми перезаписуємо контакт.

Функція add_contact повертає рядок, що підтверджує успішне додавання контакту: "Contact added.".

Необхідно зауважити, що ця функція не має вбудованих перевірок на помилки введення. Наприклад, якщо args не містить двох елементів, ця функція викличе помилку ValueError.

ValueError: not enough values to unpack (expected 2, got 0)

Обробку помилок в цьому домашньому завданні залиште на свій розсуд, бо в наступному домашньому завданні ми додамо обробку помилок через декоратори.
Критерії оцінювання:

    Бот повинен перебувати в нескінченному циклі, чекаючи команди користувача.

    Бот завершує свою роботу, якщо зустрічає слова: "close" або "exit".

    Бот не чутливий до регістру введених команд.

    Бот приймає команди:

    "hello", та відповідає у консоль повідомленням "How can I help you?"

    "add username phone". За цією командою бот зберігає у пам'яті, наприклад у словнику, новий контакт. Користувач вводить ім'я username та номер телефону phone, обов'язково через пробіл.

    "change username phone". За цією командою бот зберігає в пам'яті новий номер телефону phone для контакту username, що вже існує в записнику.  

    "phone username" За цією командою бот виводить у консоль номер телефону для зазначеного контакту username.

    "all". За цією командою бот виводить всі збереженні контакти з номерами телефонів у консоль.

    "close", "exit" за будь-якою з цих команд бот завершує свою роботу після того, як виведе у консоль повідомлення "Good bye!" та завершить своє виконання.

    Логіка команд реалізована в окремих функціях і ці функції приймають на вхід один або декілька рядків та повертають рядок.

    Вся логіка взаємодії з користувачем реалізована у функції main, всі print та input відбуваються тільки там.

